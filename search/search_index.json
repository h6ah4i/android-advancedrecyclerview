{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Advanced RecyclerView \u00b6 Advanded RecyclerView is an extension library of the RecyclerView which brings powerful features, such as Drag & Drop, Swipe, Expand, combining Adapters, etc... Demo app \u00b6 The above demo video was taken with a very old version of this library (v0.6 - Feb 2, 2015) . Now the app contains 26 demos ! Let's give it a try Phirosophies \u00b6 Never inherit RecyclerView class Reduces library conflictions, easy to integrate with existing code Implement each features as separated modules Pick features only what you need Primitive API set rather than user-friendly huge API sets Looks difficult at a glance, but gives great flexibility like original RecyclerView Features \u00b6 Swipe Swipe dismiss and swipe pinning operation. (like Google's Inbox app) Drag and Drop Smooth item reordering with linear list ( LinearLayoutManager ). It behaves like the playlist of Google's Play Music app. Also drag & drop work with GridLayoutManager and StaggeredGridLayoutManager . Expand A list with collapsible groups and its children. This feature is port of the ExpandableListView of Android framework. Wrapper adapter Inject additional functionalities to RecyclerView.Adapter by using the Decorator patten (Header, Footer, Section, Combining multiple adapters, etc...) Misc. All swipe, drag and drop, expand and wrapper adapter features work together! An ItemAnimator , it behaves exact the same as the default SimpleItemAnimator , but its code is refactored. More easy to customize! Some ItemDecoration s. Adding drop shadows to each items, drawing separators.","title":"Home"},{"location":"#advanced-recyclerview","text":"Advanded RecyclerView is an extension library of the RecyclerView which brings powerful features, such as Drag & Drop, Swipe, Expand, combining Adapters, etc...","title":"Advanced RecyclerView"},{"location":"#demo-app","text":"The above demo video was taken with a very old version of this library (v0.6 - Feb 2, 2015) . Now the app contains 26 demos ! Let's give it a try","title":"Demo app"},{"location":"#phirosophies","text":"Never inherit RecyclerView class Reduces library conflictions, easy to integrate with existing code Implement each features as separated modules Pick features only what you need Primitive API set rather than user-friendly huge API sets Looks difficult at a glance, but gives great flexibility like original RecyclerView","title":"Phirosophies"},{"location":"#features","text":"Swipe Swipe dismiss and swipe pinning operation. (like Google's Inbox app) Drag and Drop Smooth item reordering with linear list ( LinearLayoutManager ). It behaves like the playlist of Google's Play Music app. Also drag & drop work with GridLayoutManager and StaggeredGridLayoutManager . Expand A list with collapsible groups and its children. This feature is port of the ExpandableListView of Android framework. Wrapper adapter Inject additional functionalities to RecyclerView.Adapter by using the Decorator patten (Header, Footer, Section, Combining multiple adapters, etc...) Misc. All swipe, drag and drop, expand and wrapper adapter features work together! An ItemAnimator , it behaves exact the same as the default SimpleItemAnimator , but its code is refactored. More easy to customize! Some ItemDecoration s. Adding drop shadows to each items, drawing separators.","title":"Features"},{"location":"faq/","text":"Drag & Drop \u00b6 Repeated animation problem \u00b6 After Drag&Drop the dragged cell restores to original position and starts the translation animation again to its dropped position. How can I fix this? Thank a lot. Original question : Repeated animation problem #5 Answer This library requires stable ID. If the getItemId() method is not implemented properly, will causes exceptions or will animates incorrectly. Related issues Issues with stable ids #7 Position Changing Between List Item #22 Swipeable \u00b6 Swipe animation not like example \u00b6 Hello ! I implemented drag&drop Recycler View as in your example and I have some annoying problem. When I swipe some item RecyclerView animates position changing. It looks like playing back my drag gesture. How to remove this effect ? I need from dropped element to stay where I left it, not animating again. Here you have a link for YouTube video with described effect : https://youtu.be/V3eBLiAkwws Original question : [HELP] Swipe animation not like example #199 Answer This library requires stable ID to work properly. Please call setHasStableIds(true) and implement the getItemId() method properly. Related issues Issues with stable ids #7 Repeated animation problem #5 Expandable \u00b6 How to lock expanding of a specific group using onBindGroupViewHolder? \u00b6 Hi, i want to lock expanding of some specific groups (ie. if the group has only one child) and want to set the groups other click event listener in my custom ExpandableItemAdapter class. i think i need to implement in onBindGoupViewHolder, but how? Original question : [Expand Problem] : How to lock expanding of a specific group using onBindGroupViewHolder? #302 Answer If you want to custom click event handling, make the onCheckCanExpandOrCollapseGroup() method always returns false, then set click listener in onCreateGroupViewHolder() (or in onBindGroupViewHolder() ). In the click event handler, collapseGroup() / expandGroup() methods can be used to control the group's expanded state. @Override public boolean onCheckCanExpandOrCollapseGroup ( MyGroupViewHolder holder , int groupPosition , int x , int y , boolean expand ) { return false ; } @Override public MyGroupViewHolder onCreateGroupViewHolder ( ViewGroup parent , int viewType ) { final LayoutInflater inflater = LayoutInflater . from ( parent . getContext ()); final View v = inflater . inflate (..., parent , false ); MyGroupViewHolder vh = new MyGroupViewHolder ( v ); vh . mSomeClickableView . setOnClickListener ( this ); return vh ; } @Override public void onClick ( View v ) { RecyclerView . ViewHolder vh = RecyclerViewAdapterUtils . getViewHolder ( v ); int flatPosition = vh . getAdapterPosition (); if ( flatPosition == RecyclerView . NO_POSITION ) { return ; } long expandablePosition = mExpandableItemManager . getExpandablePosition ( flatPosition ); int groupPosition = RecyclerViewExpandableItemManager . getPackedPositionGroup ( expandablePosition ); int childPosition = RecyclerViewExpandableItemManager . getPackedPositionChild ( expandablePosition ); // toggle expanded/collapsed if ( mExpandableItemManager . isGroupExpanded ( groupPosition )) { mExpandableItemManager . collapseGroup ( groupPosition ); } else { mExpandableItemManager . expandGroup ( groupPosition ); } } Position Changing Between List Item \u00b6 Hi, I have problem implementing expandable list with fixed recyclerview. Please see the video https://www.youtube.com/watch?v=fkcmtkZz3zo The way I do it is to resize recyclerview and recalculate the height based on how much item is expanded. Do you think it's possible to fix this issue? Original question : Position Changing Between List Item #22 Answer Please implement the getGroupId() and getChildId() methods properly that return stable IDs. Related issues Issues with stable ids #7 Repeated animation problem #5","title":"FAQ"},{"location":"faq/#drag-drop","text":"","title":"Drag &amp; Drop"},{"location":"faq/#repeated-animation-problem","text":"After Drag&Drop the dragged cell restores to original position and starts the translation animation again to its dropped position. How can I fix this? Thank a lot. Original question : Repeated animation problem #5 Answer This library requires stable ID. If the getItemId() method is not implemented properly, will causes exceptions or will animates incorrectly. Related issues Issues with stable ids #7 Position Changing Between List Item #22","title":"Repeated animation problem"},{"location":"faq/#swipeable","text":"","title":"Swipeable"},{"location":"faq/#swipe-animation-not-like-example","text":"Hello ! I implemented drag&drop Recycler View as in your example and I have some annoying problem. When I swipe some item RecyclerView animates position changing. It looks like playing back my drag gesture. How to remove this effect ? I need from dropped element to stay where I left it, not animating again. Here you have a link for YouTube video with described effect : https://youtu.be/V3eBLiAkwws Original question : [HELP] Swipe animation not like example #199 Answer This library requires stable ID to work properly. Please call setHasStableIds(true) and implement the getItemId() method properly. Related issues Issues with stable ids #7 Repeated animation problem #5","title":"Swipe animation not like example"},{"location":"faq/#expandable","text":"","title":"Expandable"},{"location":"faq/#how-to-lock-expanding-of-a-specific-group-using-onbindgroupviewholder","text":"Hi, i want to lock expanding of some specific groups (ie. if the group has only one child) and want to set the groups other click event listener in my custom ExpandableItemAdapter class. i think i need to implement in onBindGoupViewHolder, but how? Original question : [Expand Problem] : How to lock expanding of a specific group using onBindGroupViewHolder? #302 Answer If you want to custom click event handling, make the onCheckCanExpandOrCollapseGroup() method always returns false, then set click listener in onCreateGroupViewHolder() (or in onBindGroupViewHolder() ). In the click event handler, collapseGroup() / expandGroup() methods can be used to control the group's expanded state. @Override public boolean onCheckCanExpandOrCollapseGroup ( MyGroupViewHolder holder , int groupPosition , int x , int y , boolean expand ) { return false ; } @Override public MyGroupViewHolder onCreateGroupViewHolder ( ViewGroup parent , int viewType ) { final LayoutInflater inflater = LayoutInflater . from ( parent . getContext ()); final View v = inflater . inflate (..., parent , false ); MyGroupViewHolder vh = new MyGroupViewHolder ( v ); vh . mSomeClickableView . setOnClickListener ( this ); return vh ; } @Override public void onClick ( View v ) { RecyclerView . ViewHolder vh = RecyclerViewAdapterUtils . getViewHolder ( v ); int flatPosition = vh . getAdapterPosition (); if ( flatPosition == RecyclerView . NO_POSITION ) { return ; } long expandablePosition = mExpandableItemManager . getExpandablePosition ( flatPosition ); int groupPosition = RecyclerViewExpandableItemManager . getPackedPositionGroup ( expandablePosition ); int childPosition = RecyclerViewExpandableItemManager . getPackedPositionChild ( expandablePosition ); // toggle expanded/collapsed if ( mExpandableItemManager . isGroupExpanded ( groupPosition )) { mExpandableItemManager . collapseGroup ( groupPosition ); } else { mExpandableItemManager . expandGroup ( groupPosition ); } }","title":"How to lock expanding of a specific group using onBindGroupViewHolder?"},{"location":"faq/#position-changing-between-list-item","text":"Hi, I have problem implementing expandable list with fixed recyclerview. Please see the video https://www.youtube.com/watch?v=fkcmtkZz3zo The way I do it is to resize recyclerview and recalculate the height based on how much item is expanded. Do you think it's possible to fix this issue? Original question : Position Changing Between List Item #22 Answer Please implement the getGroupId() and getChildId() methods properly that return stable IDs. Related issues Issues with stable ids #7 Repeated animation problem #5","title":"Position Changing Between List Item"},{"location":"getting-started/","text":"Installation \u00b6 Add the following lines of code into your build.gradle . dependencies { implementation ( 'com.h6ah4i.android.widget.advrecyclerview:advrecyclerview:[VERSION_CODE_GOES_HERE]@aar' ){ transitive = true } } NOTE: This library is served on jCenter . If the above gradle setting not getting work, try adding the following lines. repositories { jcenter () } What's next? \u00b6 First, I recommend you to learn about plain RecyclerView . Basic knowledges about RecyclerView are required before using this library. The following tutorial is good for starting point; Creating Lists and Cards | Android Developers - Training If you've already know well about plain RecyclerView , proceed to each sections written about what you want to use: Wrapper Adapter ComposedAdapter Headers & Footers Insertion & Filtering Drag & Drop Swipeable Expandable Other references \u00b6 Demo app code Install the demo app from Google Play Check the demo app code on GitHub Official RecyclerView reference Creating Lists and Cards --- Android Developers - Training RecyclerView --- Android Developers - Reference Check the Issues page of Advanced RecyclerView Issues - Advanced RecyclerView --- GitHub Javadoc Javadoc - Advanced RecyclerView","title":"Getting Started"},{"location":"getting-started/#installation","text":"Add the following lines of code into your build.gradle . dependencies { implementation ( 'com.h6ah4i.android.widget.advrecyclerview:advrecyclerview:[VERSION_CODE_GOES_HERE]@aar' ){ transitive = true } } NOTE: This library is served on jCenter . If the above gradle setting not getting work, try adding the following lines. repositories { jcenter () }","title":"Installation"},{"location":"getting-started/#whats-next","text":"First, I recommend you to learn about plain RecyclerView . Basic knowledges about RecyclerView are required before using this library. The following tutorial is good for starting point; Creating Lists and Cards | Android Developers - Training If you've already know well about plain RecyclerView , proceed to each sections written about what you want to use: Wrapper Adapter ComposedAdapter Headers & Footers Insertion & Filtering Drag & Drop Swipeable Expandable","title":"What's next?"},{"location":"getting-started/#other-references","text":"Demo app code Install the demo app from Google Play Check the demo app code on GitHub Official RecyclerView reference Creating Lists and Cards --- Android Developers - Training RecyclerView --- Android Developers - Reference Check the Issues page of Advanced RecyclerView Issues - Advanced RecyclerView --- GitHub Javadoc Javadoc - Advanced RecyclerView","title":"Other references"},{"location":"license/","text":"Copyright (C) 2015 Haruki Hasegawa Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"advanced-examples/draggable-swipeable/","text":"One of the most advanced example which uses Draggable and Swipeable features. See the source code on GitHub Block diagram \u00b6 Screenshots \u00b6 Screenshot 1 Screenshot 2","title":"Draggable + Swipeable"},{"location":"advanced-examples/draggable-swipeable/#block-diagram","text":"","title":"Block diagram"},{"location":"advanced-examples/draggable-swipeable/#screenshots","text":"Screenshot 1 Screenshot 2","title":"Screenshots"},{"location":"advanced-examples/expandable-draggable-section/","text":"One of the most advanced example which uses Expandable, Draggable and Swipeable features all together. See the source code on GitHub Block diagram \u00b6 Screenshots \u00b6 Screenshot 1 Screenshot 2","title":"Expandable + Draggable with Section"},{"location":"advanced-examples/expandable-draggable-section/#block-diagram","text":"","title":"Block diagram"},{"location":"advanced-examples/expandable-draggable-section/#screenshots","text":"Screenshot 1 Screenshot 2","title":"Screenshots"},{"location":"advanced-examples/expandable-draggable-swipeable/","text":"One of the most advanced example which uses Expandable, Draggable and Swipeable features all together. See the source code on GitHub Block diagram \u00b6 Screenshots \u00b6 Screenshot 1 Screenshot 2","title":"Expandable + Draggable + Swipeable"},{"location":"advanced-examples/expandable-draggable-swipeable/#block-diagram","text":"","title":"Block diagram"},{"location":"advanced-examples/expandable-draggable-swipeable/#screenshots","text":"Screenshot 1 Screenshot 2","title":"Screenshots"},{"location":"draggable/","text":"Block diagram \u00b6 Classes / Interfaces \u00b6 Class/Interface name Javadoc Description RecyclerViewDragDropManager View Provides Drag & Drop sort operation DraggableItemAdapter<T> View Implement this interface on your RecyclerView.Adapter DraggableItemViewHolder View Implement this interface on your RecyclerView.ViewHolder DraggableItemConstants View Constant values area declared in this interface DraggableItemAnimator View An ItemAnimator which implements special drag & drop effect","title":"Overview"},{"location":"draggable/#block-diagram","text":"","title":"Block diagram"},{"location":"draggable/#classes-interfaces","text":"Class/Interface name Javadoc Description RecyclerViewDragDropManager View Provides Drag & Drop sort operation DraggableItemAdapter<T> View Implement this interface on your RecyclerView.Adapter DraggableItemViewHolder View Implement this interface on your RecyclerView.ViewHolder DraggableItemConstants View Constant values area declared in this interface DraggableItemAnimator View An ItemAnimator which implements special drag & drop effect","title":"Classes / Interfaces"},{"location":"draggable/examples/","text":"\u00bb Minimal example \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Basic example \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Start dragging start on long press \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Draggable with Sections \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Uses onCheckCanDrop() \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb With GridLayoutManager \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb With StaggeredGridLayoutManager \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub","title":"Examples"},{"location":"draggable/examples/#minimal-example","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Minimal example"},{"location":"draggable/examples/#basic-example","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Basic example"},{"location":"draggable/examples/#start-dragging-start-on-long-press","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Start dragging start on long press"},{"location":"draggable/examples/#draggable-with-sections","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Draggable with Sections"},{"location":"draggable/examples/#uses-oncheckcandrop","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Uses onCheckCanDrop()"},{"location":"draggable/examples/#with-gridlayoutmanager","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; With GridLayoutManager"},{"location":"draggable/examples/#with-staggeredgridlayoutmanager","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; With StaggeredGridLayoutManager"},{"location":"draggable/tutorial/","text":"Just looking for a sample code? Check the minimal drag & drop sample code on GitHub . Tutorial \u00b6 Step 1. Make the adapter supports stable IDs \u00b6 Attention This step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...) class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { MyAdapter () { setHasStableIds ( true ); } @Override public long getItemId ( int position ) { // requires static value, it means need to keep the same value // even if the item position has been changed. return mItems . get ( position ). getId (); } } Step 2. Modify layout file of item views \u00b6 Put a drag handle view to the layout XML of item view. <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> </FrameLayout> <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> <!-- Drag handle --> <View android:id= \"@+id/drag_handle\" android:layout_width= \"32dp\" android:layout_height= \"match_parent\" /> </FrameLayout> Step 3. Modify ViewHolder \u00b6 Change parent class to AbstractDraggableItemViewHolder . Implement getSwipeableContainerView() method Note The AbstractSwipeableItemViewHolder class is a convenience class which implements boilerplace methods of DraggableItemViewHolder . class MyAdapter ... { static class MyViewHolder extends RecyclerView . ViewHolder { TextView textView ; MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); } } ... } class MyAdapter ... { static class MyViewHolder extends AbstractDraggableItemViewHolder { TextView textView ; View dragHandle ; public MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); dragHandle = v . findViewById ( R . id . drag_hanle ); } } } Step 4. Implement the DraggableItemAdapter interface \u00b6 class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { ... } class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > implements DraggableItemAdapter < MyAdapter . MyViewHolder > { @Override boolean onCheckCanStartDrag ( MyAdapter . MyViewHolder holder , int position , int x , int y ) { // see the sub-section for details } @Override void onMoveItem ( int fromPosition , int toPosition ) { // see the sub-section for details } @Override ItemDraggableRange onGetItemDraggableRange ( MyAdapter . MyViewHolder holder , int position ) { // just return null for default behavior return null ; } @Override boolean onCheckCanDrop ( int draggingPosition , int dropPosition ) { // this method is not used unless calling `RecyclerViewDragDropManager.setCheckCanDropEnabled(true)` explicitly. return true ; } @Override public void onItemDragStarted ( int position ) { notifyDataSetChanged (); } @Override public void onItemDragFinished ( int fromPosition , int toPosition , boolean result ) { notifyDataSetChanged (); } } Implement onCheckCanStartDrag() \u00b6 This method is invoked by the library whether to check the touched finger position is inside of the dragHandle view . Return true if the specified position x and y is inside of the dragHandle view. Note that the offset parameter x and y are measured from top-left of itemView . Basic implementation: boolean onCheckCanStartDrag ( MyAdapter . MyViewHolder holder , int position , int x , int y ) { View itemView = holder . itemView ; View dragHandle = holder . dragHandle ; int handleWidth = dragHandle . getWidth (); int handleHeight = dragHandle . getHeight (); int handleLeft = dragHandle . getLeft (); int handleTop = dragHnadle . getTop (); return ( x >= handleLeft ) && ( x < handleLeft + handleWidth ) && ( y >= handleTop ) && ( y < handleTop + handleHeight ); } Implement onMoveItem() \u00b6 This method is invoked by the library when finished dragging. Basic implemtation will be like the follwing; List < MyItem > items ; @Override void onMoveItem ( int fromPosition , int toPosition ) { MyItem removed = items . remove ( fromPosition ); items . add ( toPosition , removed ); } Step 5. Modify initialization process of RecyclerView \u00b6 Put some additional initialization process in your Activity / Fragment. Instantiate RecyclerViewDragManager Create a wrapped adapter and set it to RecyclerView Attach RecyclerView to RecyclerViewDragManager void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); MyAdapter adapter = new MyAdapter (); recyclerView . setAdapter ( adapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); } void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); RecyclerViewDragManager dragDropManager = new RecyclerViewDragManager (); MyAdapter adapter = new MyAdapter (); RecyclerView . Adapter wrappedAdapter = dragDropManager . createWrappedAdapter ( adapter ); recyclerView . setAdapter ( wrappedAdapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); // disable change animations (( SimpleItemAnimator ) mRecyclerView . getItemAnimator ()). setSupportsChangeAnimations ( false ); // [OPTIONAL] // dragDropManager.setInitiateOnTouch(true); // dragDropManager.setInitiateOnLongPress(true); // dragDropManager.setInitiateOnMove(true); dragDropManager . attachRecyclerView ( recyclerView ); } Step 6. Custom more and details of the implementation \u00b6 Please refer to the demo app implementation for more details.","title":"Tutorial"},{"location":"draggable/tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"draggable/tutorial/#step-1-make-the-adapter-supports-stable-ids","text":"Attention This step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...) class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { MyAdapter () { setHasStableIds ( true ); } @Override public long getItemId ( int position ) { // requires static value, it means need to keep the same value // even if the item position has been changed. return mItems . get ( position ). getId (); } }","title":"Step 1. Make the adapter supports stable IDs"},{"location":"draggable/tutorial/#step-2-modify-layout-file-of-item-views","text":"Put a drag handle view to the layout XML of item view. <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> </FrameLayout> <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> <!-- Drag handle --> <View android:id= \"@+id/drag_handle\" android:layout_width= \"32dp\" android:layout_height= \"match_parent\" /> </FrameLayout>","title":"Step 2. Modify layout file of item views"},{"location":"draggable/tutorial/#step-3-modify-viewholder","text":"Change parent class to AbstractDraggableItemViewHolder . Implement getSwipeableContainerView() method Note The AbstractSwipeableItemViewHolder class is a convenience class which implements boilerplace methods of DraggableItemViewHolder . class MyAdapter ... { static class MyViewHolder extends RecyclerView . ViewHolder { TextView textView ; MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); } } ... } class MyAdapter ... { static class MyViewHolder extends AbstractDraggableItemViewHolder { TextView textView ; View dragHandle ; public MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); dragHandle = v . findViewById ( R . id . drag_hanle ); } } }","title":"Step 3. Modify ViewHolder"},{"location":"draggable/tutorial/#step-4-implement-the-draggableitemadapter-interface","text":"class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { ... } class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > implements DraggableItemAdapter < MyAdapter . MyViewHolder > { @Override boolean onCheckCanStartDrag ( MyAdapter . MyViewHolder holder , int position , int x , int y ) { // see the sub-section for details } @Override void onMoveItem ( int fromPosition , int toPosition ) { // see the sub-section for details } @Override ItemDraggableRange onGetItemDraggableRange ( MyAdapter . MyViewHolder holder , int position ) { // just return null for default behavior return null ; } @Override boolean onCheckCanDrop ( int draggingPosition , int dropPosition ) { // this method is not used unless calling `RecyclerViewDragDropManager.setCheckCanDropEnabled(true)` explicitly. return true ; } @Override public void onItemDragStarted ( int position ) { notifyDataSetChanged (); } @Override public void onItemDragFinished ( int fromPosition , int toPosition , boolean result ) { notifyDataSetChanged (); } }","title":"Step 4. Implement the DraggableItemAdapter interface"},{"location":"draggable/tutorial/#implement-oncheckcanstartdrag","text":"This method is invoked by the library whether to check the touched finger position is inside of the dragHandle view . Return true if the specified position x and y is inside of the dragHandle view. Note that the offset parameter x and y are measured from top-left of itemView . Basic implementation: boolean onCheckCanStartDrag ( MyAdapter . MyViewHolder holder , int position , int x , int y ) { View itemView = holder . itemView ; View dragHandle = holder . dragHandle ; int handleWidth = dragHandle . getWidth (); int handleHeight = dragHandle . getHeight (); int handleLeft = dragHandle . getLeft (); int handleTop = dragHnadle . getTop (); return ( x >= handleLeft ) && ( x < handleLeft + handleWidth ) && ( y >= handleTop ) && ( y < handleTop + handleHeight ); }","title":"Implement onCheckCanStartDrag()"},{"location":"draggable/tutorial/#implement-onmoveitem","text":"This method is invoked by the library when finished dragging. Basic implemtation will be like the follwing; List < MyItem > items ; @Override void onMoveItem ( int fromPosition , int toPosition ) { MyItem removed = items . remove ( fromPosition ); items . add ( toPosition , removed ); }","title":"Implement onMoveItem()"},{"location":"draggable/tutorial/#step-5-modify-initialization-process-of-recyclerview","text":"Put some additional initialization process in your Activity / Fragment. Instantiate RecyclerViewDragManager Create a wrapped adapter and set it to RecyclerView Attach RecyclerView to RecyclerViewDragManager void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); MyAdapter adapter = new MyAdapter (); recyclerView . setAdapter ( adapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); } void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); RecyclerViewDragManager dragDropManager = new RecyclerViewDragManager (); MyAdapter adapter = new MyAdapter (); RecyclerView . Adapter wrappedAdapter = dragDropManager . createWrappedAdapter ( adapter ); recyclerView . setAdapter ( wrappedAdapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); // disable change animations (( SimpleItemAnimator ) mRecyclerView . getItemAnimator ()). setSupportsChangeAnimations ( false ); // [OPTIONAL] // dragDropManager.setInitiateOnTouch(true); // dragDropManager.setInitiateOnLongPress(true); // dragDropManager.setInitiateOnMove(true); dragDropManager . attachRecyclerView ( recyclerView ); }","title":"Step 5. Modify initialization process of RecyclerView"},{"location":"draggable/tutorial/#step-6-custom-more-and-details-of-the-implementation","text":"Please refer to the demo app implementation for more details.","title":"Step 6. Custom more and details of the implementation"},{"location":"expandable/","text":"Block diagram \u00b6 Classes / Interfaces \u00b6 Class/Interface name Javadoc Description RecyclerViewExpandableItemManager View Provides Expandable item function \u3000 ExpandableItemViewHolder View Implement this interface on your RecyclerView.ViewHolder ExpandableItemAdapter<GVH, CVH> View Implement this interface on your RecyclerView.Adapter ExpandableDraggableItemAdapter<GVH, CVH> View (optional) Implement this interface on your RecyclerView.Adapter to support Drag & Drop sort operation ExpandableSwipeableItemAdapter<GVH, CVH> View (optional) Implement this interface on your RecyclerView.Adapter to support Swipe operation ExpandableItemConstants View Constant values area declared in this interface AbstractExpandableItemAdapter<GVH, CVH> View","title":"Overview"},{"location":"expandable/#block-diagram","text":"","title":"Block diagram"},{"location":"expandable/#classes-interfaces","text":"Class/Interface name Javadoc Description RecyclerViewExpandableItemManager View Provides Expandable item function \u3000 ExpandableItemViewHolder View Implement this interface on your RecyclerView.ViewHolder ExpandableItemAdapter<GVH, CVH> View Implement this interface on your RecyclerView.Adapter ExpandableDraggableItemAdapter<GVH, CVH> View (optional) Implement this interface on your RecyclerView.Adapter to support Drag & Drop sort operation ExpandableSwipeableItemAdapter<GVH, CVH> View (optional) Implement this interface on your RecyclerView.Adapter to support Swipe operation ExpandableItemConstants View Constant values area declared in this interface AbstractExpandableItemAdapter<GVH, CVH> View","title":"Classes / Interfaces"},{"location":"expandable/examples/","text":"\u00bb Minimal example \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Basic example \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Add/Remove items \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Control initial state of groups \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub","title":"Examples"},{"location":"expandable/examples/#minimal-example","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Minimal example"},{"location":"expandable/examples/#basic-example","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Basic example"},{"location":"expandable/examples/#addremove-items","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Add/Remove items"},{"location":"expandable/examples/#control-initial-state-of-groups","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Control initial state of groups"},{"location":"expandable/tutorial/","text":"Just looking for a sample code? Check the minimal expand & collapse sample code on GitHub . Tutorial \u00b6 Step 1. Extend AbstractExpandableItemAdapter instead of RecyclerView.Adapter \u00b6 First, you need to extend AbstractExpandableItemAdapter to use expandable items feature. This class implements RecyclerView.Adapter 's methods and some of them are sealed via final keyword. Instead, it provides some Group / Child prefixed version of RecyclerView.Adapter methods. class MyChildItem { public long id ; } class MyGroupItem { public long id ; List < MyChildItem > children ; } class MyAdapter extends AbstractExpandableItemAdapter < MyAdapter . MyGroupVH , MyAdapter . MyChildVH > { List < MyGroupItem > items ; public MyAdapter () { setHasStableIds ( true ); // this is required for expandable feature. } @Override public int getGroupCount () { ... } @Override public int getChildCount ( int groupPosition ) { ... } @Override public long getGroupId ( int groupPosition ) { ... } @Override public long getChildId ( int groupPosition , int childPosition ) { ... } @Override public MyGroupVH onCreateGroupViewHolder ( ViewGroup parent , int viewType ) { ... } @Override public MyChildViewHolder onCreateChildViewHolder ( ViewGroup parent , int viewType ) { ... } @Override public void onBindGroupViewHolder ( MyGroupVH holder , int groupPosition , int viewType ) { ... } @Override public void onBindChildViewHolder ( MyChildViewHolder holder , int groupPosition , int childPosition , int viewType ) { ... } @Override public boolean onCheckCanExpandOrCollapseGroup ( MyGroupVH holder , int groupPosition , int x , int y , boolean expand ) { ... } } Step 2. Implement each method of AbstractExpandableItemAdapter \u00b6 Step 3. Implement getGroupCount() / getChildCount() \u00b6 The corresponding RecyclerView.Adapter 's method is getItemCount() . @Override public int getGroupCount () { return items . size (); } @Override public int getChildCount ( int groupPosition ) { reuturn items . get ( groupPosition ). size (); } Step 4. Implement getGroupId() / getChildId() \u00b6 The corresponding RecyclerView.Adapter 's method is getItemId() . @Override public int getGroupId ( int groupPosition ) { return items . get ( groupPosition ). id ; } @Override public int getChildId ( int groupPosition , int childPosition ) { reuturn items . get ( groupPosition ). children . get ( childPosition ). id ; } Step 5. Implement onCreateGroupViewHolder() / onCreateChildViewHolder() \u00b6 The corresponding RecyclerView.Adapter 's method is onCreateViewHolder() . @Override public MyGroupVH onCreateGroupViewHolder ( ViewGroup parent , int viewType ) { View v = LayoutInfrater . from ( parent . getContext ()). inflate ( R . layout . item_group , parent , false ); return new MyGroupVH ( v ); } @Override public MyChildViewHolder onCreateChildViewHolder ( ViewGroup parent , int viewType ) { View v = LayoutInfrater . from ( parent . getContext ()). inflate ( R . layout . item_child , parent , false ); return new MyChildVH ( v ); } Step 6. Implement onBindGroupViewHolder() / onBindChildViewHolder() \u00b6 The corresponding RecyclerView.Adapter 's method is onBindViewHolder() . @Override public void onBindGroupViewHolder ( MyGroupVH holder , int groupPosition , int viewType ) { MyGroupItem item = items . get ( groupPosition ); holder . text . setText (...); } @Override public void onBindChildViewHolder ( MyChildViewHolder holder , int groupPosition , int childPosition , int viewType ) { MyChildItem item = items . get ( groupPosition ). children . get ( childPosition ); holder . text . setText (...); } Step 7. Implement onCheckCanExpandOrCollapseGroup() \u00b6 Just returns true for make group items automatically respond to click events. @Override public boolean onCheckCanExpandOrCollapseGroup ( MyGroupViewHolder holder , int groupPosition , int x , int y , boolean expand ) { return true ; } [Tip] If you want to handle expand/colappse action manually Make this method reutrns false . Then call RecyclerViewExpandableItemManager.expandGroup() / collapseGroup() on click item events. \u00bb Sample code: AddRemoveExpandableExampleAdapter#handleOnClickGroupItemContainerView() \u00bb Related issue: Force expand/colapse #11 Step 8. Custom more and details of the implementation \u00b6 Please refer to the demo app implementation for more details.","title":"Tutorial"},{"location":"expandable/tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"expandable/tutorial/#step-1-extend-abstractexpandableitemadapter-instead-of-recyclerviewadapter","text":"First, you need to extend AbstractExpandableItemAdapter to use expandable items feature. This class implements RecyclerView.Adapter 's methods and some of them are sealed via final keyword. Instead, it provides some Group / Child prefixed version of RecyclerView.Adapter methods. class MyChildItem { public long id ; } class MyGroupItem { public long id ; List < MyChildItem > children ; } class MyAdapter extends AbstractExpandableItemAdapter < MyAdapter . MyGroupVH , MyAdapter . MyChildVH > { List < MyGroupItem > items ; public MyAdapter () { setHasStableIds ( true ); // this is required for expandable feature. } @Override public int getGroupCount () { ... } @Override public int getChildCount ( int groupPosition ) { ... } @Override public long getGroupId ( int groupPosition ) { ... } @Override public long getChildId ( int groupPosition , int childPosition ) { ... } @Override public MyGroupVH onCreateGroupViewHolder ( ViewGroup parent , int viewType ) { ... } @Override public MyChildViewHolder onCreateChildViewHolder ( ViewGroup parent , int viewType ) { ... } @Override public void onBindGroupViewHolder ( MyGroupVH holder , int groupPosition , int viewType ) { ... } @Override public void onBindChildViewHolder ( MyChildViewHolder holder , int groupPosition , int childPosition , int viewType ) { ... } @Override public boolean onCheckCanExpandOrCollapseGroup ( MyGroupVH holder , int groupPosition , int x , int y , boolean expand ) { ... } }","title":"Step 1. Extend AbstractExpandableItemAdapter instead of RecyclerView.Adapter"},{"location":"expandable/tutorial/#step-2-implement-each-method-of-abstractexpandableitemadapter","text":"","title":"Step 2. Implement each method of AbstractExpandableItemAdapter"},{"location":"expandable/tutorial/#step-3-implement-getgroupcount-getchildcount","text":"The corresponding RecyclerView.Adapter 's method is getItemCount() . @Override public int getGroupCount () { return items . size (); } @Override public int getChildCount ( int groupPosition ) { reuturn items . get ( groupPosition ). size (); }","title":"Step 3. Implement getGroupCount() / getChildCount()"},{"location":"expandable/tutorial/#step-4-implement-getgroupid-getchildid","text":"The corresponding RecyclerView.Adapter 's method is getItemId() . @Override public int getGroupId ( int groupPosition ) { return items . get ( groupPosition ). id ; } @Override public int getChildId ( int groupPosition , int childPosition ) { reuturn items . get ( groupPosition ). children . get ( childPosition ). id ; }","title":"Step 4. Implement getGroupId() / getChildId()"},{"location":"expandable/tutorial/#step-5-implement-oncreategroupviewholder-oncreatechildviewholder","text":"The corresponding RecyclerView.Adapter 's method is onCreateViewHolder() . @Override public MyGroupVH onCreateGroupViewHolder ( ViewGroup parent , int viewType ) { View v = LayoutInfrater . from ( parent . getContext ()). inflate ( R . layout . item_group , parent , false ); return new MyGroupVH ( v ); } @Override public MyChildViewHolder onCreateChildViewHolder ( ViewGroup parent , int viewType ) { View v = LayoutInfrater . from ( parent . getContext ()). inflate ( R . layout . item_child , parent , false ); return new MyChildVH ( v ); }","title":"Step 5. Implement onCreateGroupViewHolder() / onCreateChildViewHolder()"},{"location":"expandable/tutorial/#step-6-implement-onbindgroupviewholder-onbindchildviewholder","text":"The corresponding RecyclerView.Adapter 's method is onBindViewHolder() . @Override public void onBindGroupViewHolder ( MyGroupVH holder , int groupPosition , int viewType ) { MyGroupItem item = items . get ( groupPosition ); holder . text . setText (...); } @Override public void onBindChildViewHolder ( MyChildViewHolder holder , int groupPosition , int childPosition , int viewType ) { MyChildItem item = items . get ( groupPosition ). children . get ( childPosition ); holder . text . setText (...); }","title":"Step 6. Implement onBindGroupViewHolder() / onBindChildViewHolder()"},{"location":"expandable/tutorial/#step-7-implement-oncheckcanexpandorcollapsegroup","text":"Just returns true for make group items automatically respond to click events. @Override public boolean onCheckCanExpandOrCollapseGroup ( MyGroupViewHolder holder , int groupPosition , int x , int y , boolean expand ) { return true ; } [Tip] If you want to handle expand/colappse action manually Make this method reutrns false . Then call RecyclerViewExpandableItemManager.expandGroup() / collapseGroup() on click item events. \u00bb Sample code: AddRemoveExpandableExampleAdapter#handleOnClickGroupItemContainerView() \u00bb Related issue: Force expand/colapse #11","title":"Step 7. Implement onCheckCanExpandOrCollapseGroup()"},{"location":"expandable/tutorial/#step-8-custom-more-and-details-of-the-implementation","text":"Please refer to the demo app implementation for more details.","title":"Step 8. Custom more and details of the implementation"},{"location":"javadoc/","text":"Redirecting... \u00b6","title":"Javadoc"},{"location":"javadoc/#redirecting","text":"","title":"Redirecting..."},{"location":"swipeable/","text":"Block diagram \u00b6 Classes / Interfaces \u00b6 Class/Interface name Javadoc Description RecyclerViewSwipeManager View Provides Swipe operation SwipeableItemAdapter<T> View Implement this interface on your RecyclerView.Adapter SwipeableItemViewHolder View Implement this interface on your RecyclerView.ViewHolder SwipeableItemConstants View Constant values area declared in this interface SwipeDismissItemAnimator View An ItemAnimator implements swipe dismiss animation","title":"Overview"},{"location":"swipeable/#block-diagram","text":"","title":"Block diagram"},{"location":"swipeable/#classes-interfaces","text":"Class/Interface name Javadoc Description RecyclerViewSwipeManager View Provides Swipe operation SwipeableItemAdapter<T> View Implement this interface on your RecyclerView.Adapter SwipeableItemViewHolder View Implement this interface on your RecyclerView.ViewHolder SwipeableItemConstants View Constant values area declared in this interface SwipeDismissItemAnimator View An ItemAnimator implements swipe dismiss animation","title":"Classes / Interfaces"},{"location":"swipeable/examples/","text":"\u00bb Minimal example \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Basic example \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Start swiping on long press \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Buttons under swipeable items \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb With vertical orientation \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb With ViewPager \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub","title":"Examples"},{"location":"swipeable/examples/#minimal-example","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Minimal example"},{"location":"swipeable/examples/#basic-example","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Basic example"},{"location":"swipeable/examples/#start-swiping-on-long-press","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Start swiping on long press"},{"location":"swipeable/examples/#buttons-under-swipeable-items","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Buttons under swipeable items"},{"location":"swipeable/examples/#with-vertical-orientation","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; With vertical orientation"},{"location":"swipeable/examples/#with-viewpager","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; With ViewPager"},{"location":"swipeable/tutorial/","text":"Just looking for a sample code? Check the minimal swipe sample code on GitHub . Tutorial \u00b6 Step 1. Make the adapter supports stable IDs \u00b6 Attention This step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...) class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { MyAdapter () { setHasStableIds ( true ); } @Override public long getItemId ( int position ) { // requires static value, it means need to keep the same value // even if the item position has been changed. return mItems . get ( position ). getId (); } } Step 2. Modify layout file of item views \u00b6 Wrap content views with another FrameLayout whitch has @+id/container ID. <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> </FrameLayout> <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- for getSwipeableContainerView() --> <FrameLayout android:id= \"@+id/container\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> </FrameLayout> </FrameLayout> Step 3. Modify ViewHolder \u00b6 Change parent class to AbstractSwipeableItemViewHolder . Implement getSwipeableContainerView() method Note The AbstractSwipeableItemViewHolder class is a convenience class which implements boilerplace methods of SwipeableItemViewHolder . class MyAdapter ... { static class MyViewHolder extends RecyclerView . ViewHolder { TextView textView ; MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); } } ... } class MyAdapter ... { static class MyViewHolder extends AbstractSwipeableItemViewHolder { TextView textView ; FrameLayout containerView ; public MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); containerView = ( FrameLayout ) v . findViewById ( R . id . container ); } @Override public View getSwipeableContainerView () { return containerView ; } } } Step 4. Implement the SwipeableItemAdapter interface \u00b6 class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { ... } class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > implements SwipeableItemAdapter < MyAdapter . MyViewHolder > { @Override public void onSwipeItemStarted ( MyViewHolder holder , int position ) { notifyDataSetChanged (); } @Override public int onGetSwipeReactionType ( MyViewHolder holder , int position , int x , int y ) { // Make swipeable to LEFT direction return Swipeable . REACTION_CAN_SWIPE_LEFT ; } @Override public void onSetSwipeBackground ( MyViewHolder holder , int position , int type ) { // You can set background color/resource to holder.itemView. // The argument \"type\" can be one of the followings; // - Swipeable.DRAWABLE_SWIPE_NEUTRAL_BACKGROUND // - Swipeable.DRAWABLE_SWIPE_LEFT_BACKGROUND // (- Swipeable.DRAWABLE_SWIPE_UP_BACKGROUND) // (- Swipeable.DRAWABLE_SWIPE_RIGHT_BACKGROUND) // (- Swipeable.DRAWABLE_SWIPE_DOWN_BACKGROUND) if ( type == Swipeable . DRAWABLE_SWIPE_LEFT_BACKGROUND ) { holder . itemView . setBackgroundColor ( Color . YELLOW ); } else { holder . itemView . setBackgroundColor ( Color . TRANSPARENT ); } } @Override public SwipeResultAction onSwipeItem ( MyViewHolder holder , int position , int result ) { // Return sub class of the SwipeResultAction. // // Available base (abstract) classes are; // - SwipeResultActionDefault // - SwipeResultActionMoveToSwipedDirection // - SwipeResultActionRemoveItem // - SwipeResultActionDoNothing // The argument \"result\" can be one of the followings; // // - Swipeable.RESULT_CANCELED // - Swipeable.RESULT_SWIPED_LEFT // (- Swipeable.RESULT_SWIPED_UP) // (- Swipeable.RESULT_SWIPED_RIGHT) // (- Swipeable.RESULT_SWIPED_DOWN) if ( result == Swipeable . RESULT_LEFT ) { return new SwipeResultActionMoveToSwipedDirection () { // Optionally, you can override these three methods // - void onPerformAction() // - void onSlideAnimationEnd() // - void onCleanUp() }; } else { return new SwipeResultActionDoNothing (); } } } Step 5. Modify initialization process of RecyclerView \u00b6 Put some additional initialization process in your Activity / Fragment. Instantiate RecyclerViewSwipeManager Create a wrapped adapter and set it to RecyclerView Attach RecyclerView to RecyclerViewSwipeManager void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); MyAdapter adapter = new MyAdapter (); recyclerView . setAdapter ( adapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); } void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); RecyclerViewSwipeManager swipeManager = new RecyclerViewSwipeManager (); MyAdapter adapter = new MyAdapter (); RecyclerView . Adapter wrappedAdapter = swipeManager . createWrappedAdapter ( adapter ); recyclerView . setAdapter ( wrappedAdapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); // disable change animations (( SimpleItemAnimator ) mRecyclerView . getItemAnimator ()). setSupportsChangeAnimations ( false ); swipeManager . attachRecyclerView ( recyclerView ); } Step 6. Custom more and details of the implementation \u00b6 Please refer to the demo app implementation for more details.","title":"Tutorial"},{"location":"swipeable/tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"swipeable/tutorial/#step-1-make-the-adapter-supports-stable-ids","text":"Attention This step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...) class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { MyAdapter () { setHasStableIds ( true ); } @Override public long getItemId ( int position ) { // requires static value, it means need to keep the same value // even if the item position has been changed. return mItems . get ( position ). getId (); } }","title":"Step 1. Make the adapter supports stable IDs"},{"location":"swipeable/tutorial/#step-2-modify-layout-file-of-item-views","text":"Wrap content views with another FrameLayout whitch has @+id/container ID. <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> </FrameLayout> <!-- for itemView --> <FrameLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"56dp\" > <!-- for getSwipeableContainerView() --> <FrameLayout android:id= \"@+id/container\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" > <!-- Content View(s) --> <TextView android:id= \"@android:id/text1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:gravity= \"center\" /> </FrameLayout> </FrameLayout>","title":"Step 2. Modify layout file of item views"},{"location":"swipeable/tutorial/#step-3-modify-viewholder","text":"Change parent class to AbstractSwipeableItemViewHolder . Implement getSwipeableContainerView() method Note The AbstractSwipeableItemViewHolder class is a convenience class which implements boilerplace methods of SwipeableItemViewHolder . class MyAdapter ... { static class MyViewHolder extends RecyclerView . ViewHolder { TextView textView ; MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); } } ... } class MyAdapter ... { static class MyViewHolder extends AbstractSwipeableItemViewHolder { TextView textView ; FrameLayout containerView ; public MyViewHolder ( View v ) { super ( v ); textView = ( TextView ) v . findViewById ( android . R . id . text1 ); containerView = ( FrameLayout ) v . findViewById ( R . id . container ); } @Override public View getSwipeableContainerView () { return containerView ; } } }","title":"Step 3. Modify ViewHolder"},{"location":"swipeable/tutorial/#step-4-implement-the-swipeableitemadapter-interface","text":"class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > { ... } class MyAdapter extends RecyclerView . Adapter < MyAdapter . MyViewHolder > implements SwipeableItemAdapter < MyAdapter . MyViewHolder > { @Override public void onSwipeItemStarted ( MyViewHolder holder , int position ) { notifyDataSetChanged (); } @Override public int onGetSwipeReactionType ( MyViewHolder holder , int position , int x , int y ) { // Make swipeable to LEFT direction return Swipeable . REACTION_CAN_SWIPE_LEFT ; } @Override public void onSetSwipeBackground ( MyViewHolder holder , int position , int type ) { // You can set background color/resource to holder.itemView. // The argument \"type\" can be one of the followings; // - Swipeable.DRAWABLE_SWIPE_NEUTRAL_BACKGROUND // - Swipeable.DRAWABLE_SWIPE_LEFT_BACKGROUND // (- Swipeable.DRAWABLE_SWIPE_UP_BACKGROUND) // (- Swipeable.DRAWABLE_SWIPE_RIGHT_BACKGROUND) // (- Swipeable.DRAWABLE_SWIPE_DOWN_BACKGROUND) if ( type == Swipeable . DRAWABLE_SWIPE_LEFT_BACKGROUND ) { holder . itemView . setBackgroundColor ( Color . YELLOW ); } else { holder . itemView . setBackgroundColor ( Color . TRANSPARENT ); } } @Override public SwipeResultAction onSwipeItem ( MyViewHolder holder , int position , int result ) { // Return sub class of the SwipeResultAction. // // Available base (abstract) classes are; // - SwipeResultActionDefault // - SwipeResultActionMoveToSwipedDirection // - SwipeResultActionRemoveItem // - SwipeResultActionDoNothing // The argument \"result\" can be one of the followings; // // - Swipeable.RESULT_CANCELED // - Swipeable.RESULT_SWIPED_LEFT // (- Swipeable.RESULT_SWIPED_UP) // (- Swipeable.RESULT_SWIPED_RIGHT) // (- Swipeable.RESULT_SWIPED_DOWN) if ( result == Swipeable . RESULT_LEFT ) { return new SwipeResultActionMoveToSwipedDirection () { // Optionally, you can override these three methods // - void onPerformAction() // - void onSlideAnimationEnd() // - void onCleanUp() }; } else { return new SwipeResultActionDoNothing (); } } }","title":"Step 4. Implement the SwipeableItemAdapter interface"},{"location":"swipeable/tutorial/#step-5-modify-initialization-process-of-recyclerview","text":"Put some additional initialization process in your Activity / Fragment. Instantiate RecyclerViewSwipeManager Create a wrapped adapter and set it to RecyclerView Attach RecyclerView to RecyclerViewSwipeManager void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); MyAdapter adapter = new MyAdapter (); recyclerView . setAdapter ( adapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); } void onCreate () { ... RecyclerView recyclerView = findViewById ( R . id . recyclerView ); RecyclerViewSwipeManager swipeManager = new RecyclerViewSwipeManager (); MyAdapter adapter = new MyAdapter (); RecyclerView . Adapter wrappedAdapter = swipeManager . createWrappedAdapter ( adapter ); recyclerView . setAdapter ( wrappedAdapter ); recyclerView . setLayoutManager ( new LinearLayoutManager ( this )); // disable change animations (( SimpleItemAnimator ) mRecyclerView . getItemAnimator ()). setSupportsChangeAnimations ( false ); swipeManager . attachRecyclerView ( recyclerView ); }","title":"Step 5. Modify initialization process of RecyclerView"},{"location":"swipeable/tutorial/#step-6-custom-more-and-details-of-the-implementation","text":"Please refer to the demo app implementation for more details.","title":"Step 6. Custom more and details of the implementation"},{"location":"wrapper-adapter/","text":"The WrapperAdapter is a wrapper of another adapter(s). This is a core mechanism of Advanced RecyclerView library. Drag & Drop, Swipe, Expand, Headers and Footers, etc... major features of this library are using it. We can implement additional functionalities by using Decorator pattern through the mechanism. The WrapperAdapter is an interface and it is indended to be combined with RecyclerView.Adapter . The most important role of WrapperAdapter is converting position of items by using wrapPosition() and unwrapPosition() methods. Subclasses: ComposedAdapter SimpleWrapperAdapter AbstractHeaderFooterWrapperAdapter","title":"Wrapper Adapter"},{"location":"wrapper-adapter/composed-adapter/","text":"What's ComposedAdapter ? \u00b6 The ComposedAdapter is an adapter which aggregates multiple adapters into one. dataSet = new DataSet (); composedAdapter . addAdapter ( new AdapterA ( new DataSet ())); composedAdapter . addAdapter ( new AdapterB ( new DataSet ())); composedAdapter . addAdapter ( new AdapterC ( new DataSet ())); Check the ComposedAdapter implementation on GitHub Related methods ComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter) ComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter, int position) boolean ComposedAdapter.removeAdapter(ComposedChildAdapterTag tag) The ComposedAdapter can hold the same child adapter instance multiple times like this; dataSet = new DataSet (); adapterA = new AdapterA ( dataSet ); composedAdapter . addAdapter ( adapterA ); composedAdapter . addAdapter ( adapterA ); adapterA2 = new AdapterA ( dataSet ); composedAdapter . addAdapter ( adapterA2 ); Item position handling \u00b6 The ComposedAdapter calls each child adapters as segment , also child adapter's local item position are called as offset . Related methods int ComposedAdapter.getSegment(ComposedChildAdapterTag tag) long ComposedAdapter.getSegmentedPosition(int flatPosition) int ComposedAdapter.extractSegmentPart(long segmentedPosition) int ComposedAdapter.extractSegmentOffsetPart(long segmentedPosition) Item ID and ViewType handling \u00b6 When merging adapters, we must take care about item IDs. They have to be unique in entire the dataset, but the problem is child datasets may contains the duplicated IDs. The ItemIdComposer is used to manage this problem. ItemIdComposer \u00b6 This utility class provides several static methods to handle the packed item ID value. Item IDs are expressed by 64 bits length integer in RecyclerView, so it can be embed multiple information by using bit operation technique. ItemIdComposer divides 64 bits into four chunks; view type segment , group ID , child ID and reserved bit . Bits Usage bit 63 Reserved bit 62-56 View type segment bit 55-28 Group ID bit 27-0 Child ID Check the ItemIdComposer implementation on GitHub Related methods long ItemIdComposer.composeSegment(int segment, long wrappedId) int ItemIdComposer.extractSegmentPart(long composedId) long ItemIdComposer.extractExpandableGroupIdPart(long composedId) long ItemIdComposer.extractExpandableChildIdPart(long composedId) long ItemIdComposer.extractWrappedIdPart(long composedId) boolean ItemIdComposer.isExpandableGroup(long composedId) long ItemIdComposer.composeExpandableGroupId(long groupId) long ItemIdComposer.composeExpandableChildId(long groupId, long childId) ItemViewTypeComposer \u00b6 Item view type has similar problem like item ID. The ItemViewTypeCompser manages packed item view type value that ItemIdComposer doing it for item ID. Item view types are expressed by 32 bits integer in RecyclerView, and ItemViewTypeCompser divides it into three chunks; expandable group flag , view type segment and wrapped view type code . Bits Usage bit 31 Expandable group flag (1: expandable group / 0: normal item) bit 30-24 View type segment bit 27-0 Wrapped view type code Check the ItemViewTypeComposer implementation on GitHub Related methods int ItemViewTypeComposer.composeSegment(int segment, int wrappedViewType) int ItemViewTypeComposer.extractSegmentPart(int composedViewType) int ItemViewTypeComposer.extractWrappedViewTypePart(int composedViewType) boolean ItemViewTypeComposer.isExpandableGroup(int composedViewType) How to migrate to WRAPPED adapter? \u00b6 Need to change several things to use your adapter wrapped with ComposedAdapter . Refer to the Tweak your Adapter to support adapter wrapping page for more details.","title":"ComposedAdapter"},{"location":"wrapper-adapter/composed-adapter/#whats-composedadapter","text":"The ComposedAdapter is an adapter which aggregates multiple adapters into one. dataSet = new DataSet (); composedAdapter . addAdapter ( new AdapterA ( new DataSet ())); composedAdapter . addAdapter ( new AdapterB ( new DataSet ())); composedAdapter . addAdapter ( new AdapterC ( new DataSet ())); Check the ComposedAdapter implementation on GitHub Related methods ComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter) ComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter, int position) boolean ComposedAdapter.removeAdapter(ComposedChildAdapterTag tag) The ComposedAdapter can hold the same child adapter instance multiple times like this; dataSet = new DataSet (); adapterA = new AdapterA ( dataSet ); composedAdapter . addAdapter ( adapterA ); composedAdapter . addAdapter ( adapterA ); adapterA2 = new AdapterA ( dataSet ); composedAdapter . addAdapter ( adapterA2 );","title":"What's ComposedAdapter?"},{"location":"wrapper-adapter/composed-adapter/#item-position-handling","text":"The ComposedAdapter calls each child adapters as segment , also child adapter's local item position are called as offset . Related methods int ComposedAdapter.getSegment(ComposedChildAdapterTag tag) long ComposedAdapter.getSegmentedPosition(int flatPosition) int ComposedAdapter.extractSegmentPart(long segmentedPosition) int ComposedAdapter.extractSegmentOffsetPart(long segmentedPosition)","title":"Item position handling"},{"location":"wrapper-adapter/composed-adapter/#item-id-and-viewtype-handling","text":"When merging adapters, we must take care about item IDs. They have to be unique in entire the dataset, but the problem is child datasets may contains the duplicated IDs. The ItemIdComposer is used to manage this problem.","title":"Item ID and ViewType handling"},{"location":"wrapper-adapter/composed-adapter/#itemidcomposer","text":"This utility class provides several static methods to handle the packed item ID value. Item IDs are expressed by 64 bits length integer in RecyclerView, so it can be embed multiple information by using bit operation technique. ItemIdComposer divides 64 bits into four chunks; view type segment , group ID , child ID and reserved bit . Bits Usage bit 63 Reserved bit 62-56 View type segment bit 55-28 Group ID bit 27-0 Child ID Check the ItemIdComposer implementation on GitHub Related methods long ItemIdComposer.composeSegment(int segment, long wrappedId) int ItemIdComposer.extractSegmentPart(long composedId) long ItemIdComposer.extractExpandableGroupIdPart(long composedId) long ItemIdComposer.extractExpandableChildIdPart(long composedId) long ItemIdComposer.extractWrappedIdPart(long composedId) boolean ItemIdComposer.isExpandableGroup(long composedId) long ItemIdComposer.composeExpandableGroupId(long groupId) long ItemIdComposer.composeExpandableChildId(long groupId, long childId)","title":"ItemIdComposer"},{"location":"wrapper-adapter/composed-adapter/#itemviewtypecomposer","text":"Item view type has similar problem like item ID. The ItemViewTypeCompser manages packed item view type value that ItemIdComposer doing it for item ID. Item view types are expressed by 32 bits integer in RecyclerView, and ItemViewTypeCompser divides it into three chunks; expandable group flag , view type segment and wrapped view type code . Bits Usage bit 31 Expandable group flag (1: expandable group / 0: normal item) bit 30-24 View type segment bit 27-0 Wrapped view type code Check the ItemViewTypeComposer implementation on GitHub Related methods int ItemViewTypeComposer.composeSegment(int segment, int wrappedViewType) int ItemViewTypeComposer.extractSegmentPart(int composedViewType) int ItemViewTypeComposer.extractWrappedViewTypePart(int composedViewType) boolean ItemViewTypeComposer.isExpandableGroup(int composedViewType)","title":"ItemViewTypeComposer"},{"location":"wrapper-adapter/composed-adapter/#how-to-migrate-to-wrapped-adapter","text":"Need to change several things to use your adapter wrapped with ComposedAdapter . Refer to the Tweak your Adapter to support adapter wrapping page for more details.","title":"How to migrate to WRAPPED adapter?"},{"location":"wrapper-adapter/examples/","text":"Header/Footer \u00b6 \u00bb Minimal example \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb With Expandable feature \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Add/Remove items \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub ComposedAdapter \u00b6 \u00bb Composition of all features (Draggable, Swipeable, Expandable, Header/Footer, Section) \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub Custom wrapper adapter \u00b6 \u00bb Insertion custom wrapper adapter \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub \u00bb Filtering custom wrapper adapter \u00b6 Screenshot 1 Screenshot 2 See the source code on GitHub","title":"Examples"},{"location":"wrapper-adapter/examples/#headerfooter","text":"","title":"Header/Footer"},{"location":"wrapper-adapter/examples/#minimal-example","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Minimal example"},{"location":"wrapper-adapter/examples/#with-expandable-feature","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; With Expandable feature"},{"location":"wrapper-adapter/examples/#addremove-items","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Add/Remove items"},{"location":"wrapper-adapter/examples/#composedadapter","text":"","title":"ComposedAdapter"},{"location":"wrapper-adapter/examples/#composition-of-all-features-draggable-swipeable-expandable-headerfooter-section","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Composition of all features (Draggable, Swipeable, Expandable, Header/Footer, Section)"},{"location":"wrapper-adapter/examples/#custom-wrapper-adapter","text":"","title":"Custom wrapper adapter"},{"location":"wrapper-adapter/examples/#insertion-custom-wrapper-adapter","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Insertion custom wrapper adapter"},{"location":"wrapper-adapter/examples/#filtering-custom-wrapper-adapter","text":"Screenshot 1 Screenshot 2 See the source code on GitHub","title":"&raquo; Filtering custom wrapper adapter"},{"location":"wrapper-adapter/headers-footers/","text":"When creating headers & footers, the AbstractHeaderFooterWrapperAdapter can be a good alternative to the ComposedAdapter . This class provides simple way to creating a wrapper crass for headers & footers by implementing small number of methods. Just looking for a sample code? Check the minimal header/footer sample code on GitHub . Quick quide \u00b6 Usage \u00b6 MyAdapter adapter = new MyAdapter (); MyHeadFootAdapter wrappedAdapter = new MyHeadFootAdapter ( adapter ); recyclerView . setAdapter ( wrappedAdapter ); Implementation of headers & footers wrapper adapter \u00b6 class MyHeadFootAdapter extends AbstractHeaderFooterWrapperAdapter < MyHeadFootAdapter . HeaderVH , MyHeadFootAdapter . FooterVH > { static class HeaderVH extends RecylerView . ViewHolder { ... } static class FooterVH extends RecylerView . ViewHolder { ... } public MyHeadFootAdapter ( RecyclerView . Adapter adapter ) { super . this ( adapter ); } @Override public int getHeaderItemCount () { return << NUMBER OF HEADER ITEMS GOES HERE >> ; } @Override public int getFooterItemCount () { return << NUMBER OF FOOTER ITEMS GOES HERE >> ; } @Override public HeaderVH onCreateHeaderItemViewHolder ( ViewGroup parent , int viewType ) { View v = ...; return new HeaderVH ( v ); } @Override public FooterVH onCreateFooterItemViewHolder ( ViewGroup parent , int viewType ) { View v = ...; return new FooterVH ( v ); } @Override public void onBindHeaderItemViewHolder ( HeaderVH holder , int localPosition ) { // bind data to header items views } @Override public void onBindFooterItemViewHolder ( FooterVH holder , int localPosition ) { // bind data to footer items views } } Click event handling \u00b6 The AbstractHeaderFooterWrapperAdapter extends ComposedAdapter so the same click event handling approach is required. class MyHeadFootAdapter extends AbstractHeaderFooterWrapperAdapter < MyHeadFootAdapter . HeaderVH , MyHeadFootAdapter . FooterVH > implements View . OnClickListener { @Override public HeaderVH onCreateHeaderItemViewHolder ( ViewGroup parent , int viewType ) { View v = ...; return new HeaderVH ( v ); } @Override public void onClick ( View v ) { RecyclerView rv = RecyclerViewAdapterUtils . getParentRecyclerView ( v ); RecyclerView . ViewHolder vh = rv . findContainingViewHolder ( v ); int rootPosition = vh . getAdapterPosition (); if ( rootPosition == RecyclerView . NO_POSITION ) { return ; } // need to determine adapter local position like this: RecyclerView . Adapter rootAdapter = rv . getAdapter (); int localPosition = WrapperAdapterUtils . unwrapPosition ( rootAdapter , this , rootPosition ); // get segment long segmentedPosition = getSegmentedPosition ( localPosition ); int segment = extractSegmentPart ( segmentedPosition ); int offset = extractSegmentOffsetPart ( segmentedPosition ); String message ; if ( segment == SEGMENT_TYPE_HEADER ) { // Header item is clicked ! } else if ( segment == SEGMENT_TYPE_FOOTER ) { // Footer item is clicked ! } } } Multipe view type handling \u00b6 Just same as ComposedAdapter , so need to use ItemViewTypeComposer.extractWrappedViewTypePart() when using view type. @Override public int getHeaderItemViewType ( int localPosition ) { return position % 2 ; } @Override public void onBindHeaderItemViewHolder ( HeaderViewHolder holder , int localPosition ) { int viewType = ItemViewTypeComposer . extractWrappedViewTypePart ( holder . getItemViewType ()); if ( viewType == 0 ) { ... } else { ... } }","title":"Headers & Footers"},{"location":"wrapper-adapter/headers-footers/#quick-quide","text":"","title":"Quick quide"},{"location":"wrapper-adapter/headers-footers/#usage","text":"MyAdapter adapter = new MyAdapter (); MyHeadFootAdapter wrappedAdapter = new MyHeadFootAdapter ( adapter ); recyclerView . setAdapter ( wrappedAdapter );","title":"Usage"},{"location":"wrapper-adapter/headers-footers/#implementation-of-headers-footers-wrapper-adapter","text":"class MyHeadFootAdapter extends AbstractHeaderFooterWrapperAdapter < MyHeadFootAdapter . HeaderVH , MyHeadFootAdapter . FooterVH > { static class HeaderVH extends RecylerView . ViewHolder { ... } static class FooterVH extends RecylerView . ViewHolder { ... } public MyHeadFootAdapter ( RecyclerView . Adapter adapter ) { super . this ( adapter ); } @Override public int getHeaderItemCount () { return << NUMBER OF HEADER ITEMS GOES HERE >> ; } @Override public int getFooterItemCount () { return << NUMBER OF FOOTER ITEMS GOES HERE >> ; } @Override public HeaderVH onCreateHeaderItemViewHolder ( ViewGroup parent , int viewType ) { View v = ...; return new HeaderVH ( v ); } @Override public FooterVH onCreateFooterItemViewHolder ( ViewGroup parent , int viewType ) { View v = ...; return new FooterVH ( v ); } @Override public void onBindHeaderItemViewHolder ( HeaderVH holder , int localPosition ) { // bind data to header items views } @Override public void onBindFooterItemViewHolder ( FooterVH holder , int localPosition ) { // bind data to footer items views } }","title":"Implementation of headers &amp; footers wrapper adapter"},{"location":"wrapper-adapter/headers-footers/#click-event-handling","text":"The AbstractHeaderFooterWrapperAdapter extends ComposedAdapter so the same click event handling approach is required. class MyHeadFootAdapter extends AbstractHeaderFooterWrapperAdapter < MyHeadFootAdapter . HeaderVH , MyHeadFootAdapter . FooterVH > implements View . OnClickListener { @Override public HeaderVH onCreateHeaderItemViewHolder ( ViewGroup parent , int viewType ) { View v = ...; return new HeaderVH ( v ); } @Override public void onClick ( View v ) { RecyclerView rv = RecyclerViewAdapterUtils . getParentRecyclerView ( v ); RecyclerView . ViewHolder vh = rv . findContainingViewHolder ( v ); int rootPosition = vh . getAdapterPosition (); if ( rootPosition == RecyclerView . NO_POSITION ) { return ; } // need to determine adapter local position like this: RecyclerView . Adapter rootAdapter = rv . getAdapter (); int localPosition = WrapperAdapterUtils . unwrapPosition ( rootAdapter , this , rootPosition ); // get segment long segmentedPosition = getSegmentedPosition ( localPosition ); int segment = extractSegmentPart ( segmentedPosition ); int offset = extractSegmentOffsetPart ( segmentedPosition ); String message ; if ( segment == SEGMENT_TYPE_HEADER ) { // Header item is clicked ! } else if ( segment == SEGMENT_TYPE_FOOTER ) { // Footer item is clicked ! } } }","title":"Click event handling"},{"location":"wrapper-adapter/headers-footers/#multipe-view-type-handling","text":"Just same as ComposedAdapter , so need to use ItemViewTypeComposer.extractWrappedViewTypePart() when using view type. @Override public int getHeaderItemViewType ( int localPosition ) { return position % 2 ; } @Override public void onBindHeaderItemViewHolder ( HeaderViewHolder holder , int localPosition ) { int viewType = ItemViewTypeComposer . extractWrappedViewTypePart ( holder . getItemViewType ()); if ( viewType == 0 ) { ... } else { ... } }","title":"Multipe view type handling"},{"location":"wrapper-adapter/insertion-filtering/","text":"Insertion \u00b6 Filtering \u00b6","title":"Insertion & Filtering"},{"location":"wrapper-adapter/insertion-filtering/#insertion","text":"","title":"Insertion"},{"location":"wrapper-adapter/insertion-filtering/#filtering","text":"","title":"Filtering"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/","text":"Tweak your Adapter to support adapter wrapping \u00b6 Need to tweak several things in your adapter implemtation to support wrapping adapter mechanism . Because WrapperAdapter modifies item positions , item IDs and item view types internally. \u00bb If overriding Adapter.getItemId() \u00b6 The available range of item ID value is limited, so you cannot use full range of 64-bit integer value. Must return a value greather than or equals to -(2^55) and less than or equals to 2^55 - 1 . Note This limitation is due to how ItemIdComposer packs other information into 64-bits integer value. \u00bb If overriding Adapter.getItemViewType() \u00b6 The available range of item view type value is limited, so you cannot use full range of 32-bit integer value. Must return a value greather than or equals to -(2^23) and less than or equals to 2^23 - 1 . Note This limitation is due to how ItemViewTypeComposer packs other information into 32-bits integer value. \u00bb If using ViewHolder.getAdaperPosition() / ViewHolder.getLayoutPosition()) \u00b6 Use WrapperAdapterUtils.unwrapPosition() . @Overfides void onClick ( View v ) { RecyclerView rv = RecyclerViewAdapterUtils . getParentRecyclerView ( v ); RecyclerView . ViewHolder vh = rv . findContainingViewHolder ( v ); int rootPosition = vh . getAdapterPosition (); if ( rootPosition == RecyclerView . NO_POSITION ) { return ; } // need to determine adapter local position like this: RecyclerView . Adapter rootAdapter = rv . getAdapter (); int localPosition = WrapperAdapterUtils . unwrapPosition ( rootAdapter , this , rootPosition ); Item item = mItems . get ( localPosition ); ... } \u00bb If using ViewHolder.getItemViewType() \u00b6 Use ItemViewTypeComposer.extractWrappedViewTypePart() . @Overfides void onClick ( View v ) { RecyclerView . ViewHolder vh = recyclerView . findContainingViewHolder ( v ); int rawViewType = vh . getItemViewType (); int viewType = ItemIdComposer . extractWrappedIdPart ( rawViewType ); // use \"viewType\" here to determine which type of item is clicked ... } \u00bb If using ViewHolder.getItemId() \u00b6 Use ItemIdComposer.extractWrappedIdPart() . @Overfides void onClick ( View v ) { RecyclerView . ViewHolder vh = recyclerView . findContainingViewHolder ( v ); long rawId = vh . getItemId (); long id = ItemIdComposer . extractWrappedIdPart ( rawId ); // use \"id\" here to determine which item is clicked ... } \u00bb If your adapter overrides optional methods of RecyclerView.Adapter \u00b6 Implement the WrappedAdapter interface and use the viewType parameter instead of using ViewHolder.getItemViewType() This step is only required in case of the adapter overrides the following methods; onViewAttachedToWindow() onViewDetachedFromWindow() onViewRecycled() onFailedToRecycleView() class MyInnerAdapter < VH > implements WrappedAdapter < VH > { // the following four methods are provided by WrappedAdapter interface @Overrides void onViewAttachedToWindow ( VH holder , int viewType ) { ... } @Overrides void onViewDetachedFromWindow ( VH holder , int viewType ) { ... } @Overrides void onViewRecycled ( VH holder , int viewType ) { ... } @Overrides boolean onFailedToRecycleView ( VH holder , int viewType ) { ... } // proxy to WrappedAdapter's methods @Overrides void onViewAttachedToWindow ( VH holder ) { onViewAttachedToWindow ( holder , holder . getItemViewType ()); } @Overrides void onViewDetachedFromWindow ( VH holder , int viewType ) { onViewDetachedFromWindow ( holder , holder . getItemViewType ()); } @Overrides void onViewRecycled ( VH holder , int viewType ) { onViewRecycled ( holder , holder . getItemViewType ()); } @Overrides boolean onFailedToRecycleView ( VH holder , int viewType ) { onFailedToRecycleView ( holder , holder . getItemViewType ()); } }","title":"Support adapter wrapping"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/#tweak-your-adapter-to-support-adapter-wrapping","text":"Need to tweak several things in your adapter implemtation to support wrapping adapter mechanism . Because WrapperAdapter modifies item positions , item IDs and item view types internally.","title":"Tweak your Adapter to support adapter wrapping"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/#if-overriding-adaptergetitemid","text":"The available range of item ID value is limited, so you cannot use full range of 64-bit integer value. Must return a value greather than or equals to -(2^55) and less than or equals to 2^55 - 1 . Note This limitation is due to how ItemIdComposer packs other information into 64-bits integer value.","title":"&raquo; If overriding Adapter.getItemId()"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/#if-overriding-adaptergetitemviewtype","text":"The available range of item view type value is limited, so you cannot use full range of 32-bit integer value. Must return a value greather than or equals to -(2^23) and less than or equals to 2^23 - 1 . Note This limitation is due to how ItemViewTypeComposer packs other information into 32-bits integer value.","title":"&raquo; If overriding Adapter.getItemViewType()"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/#if-using-viewholdergetadaperposition-viewholdergetlayoutposition","text":"Use WrapperAdapterUtils.unwrapPosition() . @Overfides void onClick ( View v ) { RecyclerView rv = RecyclerViewAdapterUtils . getParentRecyclerView ( v ); RecyclerView . ViewHolder vh = rv . findContainingViewHolder ( v ); int rootPosition = vh . getAdapterPosition (); if ( rootPosition == RecyclerView . NO_POSITION ) { return ; } // need to determine adapter local position like this: RecyclerView . Adapter rootAdapter = rv . getAdapter (); int localPosition = WrapperAdapterUtils . unwrapPosition ( rootAdapter , this , rootPosition ); Item item = mItems . get ( localPosition ); ... }","title":"&raquo; If using ViewHolder.getAdaperPosition() / ViewHolder.getLayoutPosition())"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/#if-using-viewholdergetitemviewtype","text":"Use ItemViewTypeComposer.extractWrappedViewTypePart() . @Overfides void onClick ( View v ) { RecyclerView . ViewHolder vh = recyclerView . findContainingViewHolder ( v ); int rawViewType = vh . getItemViewType (); int viewType = ItemIdComposer . extractWrappedIdPart ( rawViewType ); // use \"viewType\" here to determine which type of item is clicked ... }","title":"&raquo; If using ViewHolder.getItemViewType()"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/#if-using-viewholdergetitemid","text":"Use ItemIdComposer.extractWrappedIdPart() . @Overfides void onClick ( View v ) { RecyclerView . ViewHolder vh = recyclerView . findContainingViewHolder ( v ); long rawId = vh . getItemId (); long id = ItemIdComposer . extractWrappedIdPart ( rawId ); // use \"id\" here to determine which item is clicked ... }","title":"&raquo; If using ViewHolder.getItemId()"},{"location":"wrapper-adapter/migrate-to-wrapped-adapter/#if-your-adapter-overrides-optional-methods-of-recyclerviewadapter","text":"Implement the WrappedAdapter interface and use the viewType parameter instead of using ViewHolder.getItemViewType() This step is only required in case of the adapter overrides the following methods; onViewAttachedToWindow() onViewDetachedFromWindow() onViewRecycled() onFailedToRecycleView() class MyInnerAdapter < VH > implements WrappedAdapter < VH > { // the following four methods are provided by WrappedAdapter interface @Overrides void onViewAttachedToWindow ( VH holder , int viewType ) { ... } @Overrides void onViewDetachedFromWindow ( VH holder , int viewType ) { ... } @Overrides void onViewRecycled ( VH holder , int viewType ) { ... } @Overrides boolean onFailedToRecycleView ( VH holder , int viewType ) { ... } // proxy to WrappedAdapter's methods @Overrides void onViewAttachedToWindow ( VH holder ) { onViewAttachedToWindow ( holder , holder . getItemViewType ()); } @Overrides void onViewDetachedFromWindow ( VH holder , int viewType ) { onViewDetachedFromWindow ( holder , holder . getItemViewType ()); } @Overrides void onViewRecycled ( VH holder , int viewType ) { onViewRecycled ( holder , holder . getItemViewType ()); } @Overrides boolean onFailedToRecycleView ( VH holder , int viewType ) { onFailedToRecycleView ( holder , holder . getItemViewType ()); } }","title":"&raquo; If your adapter overrides optional methods of RecyclerView.Adapter"}]}